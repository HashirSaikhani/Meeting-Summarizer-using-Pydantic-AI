We added music to it, but that’s just an end-user phase. The issue is that the number we registered earlier for verification is not being approved yet. Previously, we used to add a test number where verification was required and it would get listed, but now it’s not verifying properly. It’s not clear how long approval will take. We’ve reached out but haven’t received any response. They haven’t rejected it either, they just left it pending. The API also shows the status as pending, and even in the Meta console, it still appears as pending. According to Meta’s documentation, as a solution provider you can register on their platform, but there are compliance and cost-related concerns on their side. Since we don’t need it immediately, we’ve decided to wait for now.

The main objective of this meeting is to define what we need to build. We should first discuss the broad requirements and then break them into subsets. The vision is to design a pipeline where, for example, when a new client is onboarded, the process should define how deployment will be handled, what formats their knowledge base will be in, how the initial knowledge base will be ingested, and how subsequent updates will be managed.

Currently, our reference client shares data in chat format, but we must expect other formats such as Google Docs, Word files, PDFs, text files, and transcripts. We must support both structured and unstructured data. Structured data refers to predefined, deterministic FAQs or facts, while unstructured data includes PDFs, chat logs, or random documents. The backend should handle parsing these formats, converting them into a common internal format, and storing them efficiently. We cannot directly support Excel chats right now, but if a client maintains data in Excel, we can provide guidelines to export it into a supported format instead of parsing Excel directly.

Most clients will provide documents like Word and PDFs, or chat logs, either directly or through WhatsApp. For some clients, if they cannot provide exports, we may need to listen directly to their chat systems, but this will remain optional and can be added later. Initially, our system will focus on text data, meeting transcripts, audio converted to text, and possibly images later on.

The ChatDocs app already works with unstructured data using RAG, but for this client a lot of the information is structured, like FAQs. In such cases, answers map directly to questions without needing chunking, making it deterministic and easier to maintain. Our strategy should be to start with structured data ingestion and later expand to support unstructured data like free text or PDFs.

Some facts will change periodically, such as pricing, schedules, or policy updates. We expect around 20–40 dynamic facts that may change often, so these should be stored in the database and updated via a simple admin dashboard where an admin can update values and push the changes. The system should then regenerate embeddings and replace outdated ones to ensure the chatbot provides accurate responses in real-time.

For WhatsApp integration, there are two approaches. One is live listening via the WhatsApp Business API, which is limited by WhatsApp’s restrictions and usually allows only six months of retrievable data. The other is importing historical data through backup files from Google Drive or iCloud, which allows importing all historical messages at once. After importing, we can filter and clean outdated or irrelevant messages. This way, if a client provides a year’s worth of chat backups, our system can also analyze seasonality and trends.

When the chatbot cannot answer a query, it should escalate to a human agent who replies using the same WhatsApp interface so that the end-user never realizes they switched from bot to human. This can work in two ways: either the human uses WhatsApp Business manually to reply, with our system syncing conversations in real time, or the preferred option, where the human uses our admin dashboard to view escalated queries and reply directly through it, with the backend sending responses through the WhatsApp API.

In special cases like payment verification, if a user sends an image of a receipt, the chatbot cannot verify it and must escalate to a human accountant, who then checks the payment system and replies with confirmation like “Payment received, your account has been updated.” We should also maintain a dashboard to track escalations, showing open cases, who is handling them, and reporting metrics like total escalations per day and average response time.

In summary, the flow we finalize should start with structured data ingestion for FAQs and static information, then add dynamic data updates through an admin dashboard, support unstructured data in later phases, provide WhatsApp integration through both live listening and backup imports, and finally implement a transparent human escalation system managed through a dashboard. This phased approach ensures the chatbot evolves to meet immediate and future requirements.
